/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./src/js/tinyfoot.js":()=>{eval('(function () {\n  const tinyfoot = options => {\n    const defaults = {\n      actionOriginalFN: "hide",\n      activateCallback: () => {},\n      activateOnHover: false,\n      allowMultipleFN: false,\n      anchorPattern: /(fn|footnote|note)[:\\-_\\d]/gi,\n      anchorParentTagname: \'sup\',\n      breakpoints: {},\n      deleteOnUnhover: false,\n      footnoteParentClass: \'footnote\',\n      footnoteTagname: \'li\',\n      hoverDelay: 250,\n      numberResetSelector: undefined,\n      popoverDeleteDelay: 300,\n      popoverCreateDelay: 100,\n      animationDuration: 200,\n      positionContent: true,\n      preventPageScroll: true,\n      scope: false,\n      useFootnoteOnlyOnce: true,\n      contentMarkup: `<aside class=\'tinyfoot-footnote is-positioned-bottom\' data-footnote-number=\'{{FOOTNOTENUM}}\' data-footnote-identifier=\'{{FOOTNOTEID}}\' alt=\'Footnote {{FOOTNOTENUM}}\'>\n            <div class=\'tinyfoot-footnote__wrapper\'>\n              <div class=\'tinyfoot-footnote__content\'>\n                {{FOOTNOTECONTENT}}\n              </div>\n            </div>\n            <div class=\'tinyfoot-footnote__tooltip\'></div>\n          </aside>`,\n      buttonMarkup: `<div class=\'tinyfoot-footnote__container\'>\n            <button class=\'tinyfoot-footnote__button\' id=\'{{SUP:data-footnote-backlink-ref}}\' data-footnote-number=\'{{FOOTNOTENUM}}\' data-footnote-identifier=\'{{FOOTNOTEID}}\' alt=\'See Footnote {{FOOTNOTENUM}}\' rel=\'footnote\' data-tinyfoot-footnote=\'{{FOOTNOTECONTENT}}\'>\n              <svg class=\'tinyfoot-footnote__button__circle\' viewbox=\'0 0 6 6\' preserveAspectRatio=\'xMinYMin\'><circle r=\'3\' cx=\'3\' cy=\'3\' fill=\'white\'></circle></svg>\n              <svg class=\'tinyfoot-footnote__button__circle\' viewbox=\'0 0 6 6\' preserveAspectRatio=\'xMinYMin\'><circle r=\'3\' cx=\'3\' cy=\'3\' fill=\'white\'></circle></svg>\n              <svg class=\'tinyfoot-footnote__button__circle\' viewbox=\'0 0 6 6\' preserveAspectRatio=\'xMinYMin\'><circle r=\'3\' cx=\'3\' cy=\'3\' fill=\'white\'></circle></svg>\n            </button>\n          </div>`\n    };\n    const settings = {\n      ...defaults,\n      ...options\n    };\n    const popoverStates = {};\n    const footnoteInit = () => {\n      let curResetElement, currentLastFootnoteLink, footnoteAnchors, footnoteButton, lastResetElement, parent, relevantFNLink, relevantFootnote;\n      let finalFNLinks = [],\n        footnoteIDNum,\n        footnoteLinks = [],\n        footnotes = [],\n        footnoteNum;\n      const footnoteButtonSearchQuery = settings.scope ? `${settings.scope} a[href*=\'#\']` : "a[href*=\'#\']";\n      footnoteAnchors = [...document.querySelectorAll(footnoteButtonSearchQuery)].filter(anchor => {\n        const relAttr = anchor.getAttribute("rel") || "";\n        const href = anchor.getAttribute("href") + relAttr;\n        const parentClass = anchor.closest(`[class*="${settings.footnoteParentClass}"]:not(a):not(${settings.anchorParentTagname})`);\n        return href.match(settings.anchorPattern) && !parentClass;\n      });\n      cleanFootnoteLinks(footnoteAnchors, footnoteLinks);\n      footnoteLinks.forEach(link => {\n        let relatedFN = link.getAttribute("data-footnote-ref").replace(/[:.+~*\\]\\[]/g, "\\\\$&");\n        if (settings.useFootnoteOnlyOnce) {\n          relatedFN += ":not(.footnote-processed)";\n        }\n        const closestFootnoteEl = document.querySelector(relatedFN)?.closest(settings.footnoteTagname);\n        if (closestFootnoteEl) {\n          closestFootnoteEl.classList.add("footnote-processed");\n          footnotes.push(closestFootnoteEl);\n          finalFNLinks.push(link);\n        }\n      });\n      currentLastFootnoteLink = document.querySelector("[data-footnote-identifier]:last-child");\n      footnoteIDNum = currentLastFootnoteLink ? +currentLastFootnoteLink.dataset.footnoteIdentifier : 0;\n      footnotes.forEach((footnote, i) => {\n        let footnoteContent = removeBackLinks(footnote.innerHTML.trim(), finalFNLinks[i].dataset.footnoteBacklinkRef).replace(/"/g, "&quot;").replace(/&lt;/g, "&ltsym;").replace(/&gt;/g, "&gtsym;").replace(/\'/g, "&apos;");\n        footnoteIDNum++;\n        relevantFNLink = finalFNLinks[i];\n        relevantFootnote = footnotes[i];\n        if (settings.numberResetSelector) {\n          curResetElement = relevantFNLink.closest(settings.numberResetSelector);\n          footnoteNum = curResetElement === lastResetElement ? footnoteNum + 1 : 1;\n          lastResetElement = curResetElement;\n        } else {\n          footnoteNum = footnoteIDNum;\n        }\n        if (!footnoteContent.startsWith("<")) {\n          footnoteContent = `<p>${footnoteContent}</p>`;\n        }\n        footnoteButton = settings.buttonMarkup.replace(/\\{\\{FOOTNOTENUM\\}\\}/g, footnoteNum).replace(/\\{\\{FOOTNOTEID\\}\\}/g, footnoteIDNum).replace(/\\{\\{FOOTNOTECONTENT\\}\\}/g, footnoteContent);\n        footnoteButton = replaceWithReferenceAttributes(footnoteButton, "SUP", relevantFNLink);\n        footnoteButton = replaceWithReferenceAttributes(footnoteButton, "FN", relevantFootnote);\n        const range = document.createRange();\n        const footnoteButtonElement = range.createContextualFragment(footnoteButton).firstElementChild;\n        relevantFNLink.insertAdjacentElement(\'beforebegin\', footnoteButtonElement);\n        parent = relevantFootnote.parentElement;\n        switch (settings.actionOriginalFN.toLowerCase()) {\n          case "hide":\n            relevantFNLink.classList.add("footnote-print-only");\n            relevantFootnote.classList.add("footnote-print-only");\n            deleteEmptyOrHR(parent);\n            break;\n          case "delete":\n            relevantFNLink.remove();\n            relevantFootnote.remove();\n            deleteEmptyOrHR(parent);\n            break;\n          default:\n            relevantFNLink.classList.add("footnote-print-only");\n        }\n      });\n    };\n    const cleanFootnoteLinks = (footnoteAnchors, footnoteLinks = []) => {\n      footnoteAnchors.forEach(anchor => {\n        const linkHREF = `#${anchor.getAttribute("href").split("#")[1]}`;\n        const parent = anchor.closest(settings.anchorParentTagname);\n        const child = anchor.querySelector(settings.anchorParentTagname);\n        let linkID;\n        let targetElement;\n        if (parent) {\n          linkID = (parent.id || "") + (anchor.id || "");\n          targetElement = parent;\n        } else if (child) {\n          linkID = (child.id || "") + (anchor.id || "");\n          targetElement = anchor;\n        } else {\n          linkID = anchor.id || "";\n          targetElement = anchor;\n        }\n        targetElement.dataset.footnoteBacklinkRef = linkID;\n        targetElement.dataset.footnoteRef = linkHREF;\n        footnoteLinks.push(targetElement);\n      });\n      return footnoteLinks;\n    };\n    const replaceWithReferenceAttributes = (string, referenceKeyword, referenceElement) => {\n      let refRegex = new RegExp(`\\\\{\\\\{${referenceKeyword}:([^\\\\}]*)\\\\}\\\\}`, "g");\n      let refMatches = refRegex.exec(string);\n      while (refMatches) {\n        if (refMatches[1]) {\n          const refReplaceText = referenceElement.getAttribute(refMatches[1]) || "";\n          string = string.replace(`{{${referenceKeyword}:${refMatches[1]}}}`, refReplaceText);\n        }\n        refMatches = refRegex.exec(string);\n      }\n      return string;\n    };\n    const deleteEmptyOrHR = el => {\n      let parent;\n      if (el.innerHTML.trim() === \'\' || [...el.children].filter(child => !child.classList.contains("footnote-print-only")).length === 0) {\n        parent = el.parentElement;\n        if (settings.actionOriginalFN.toLowerCase() === "delete") {\n          el.remove();\n        } else {\n          el.classList.add("footnote-print-only");\n        }\n        return deleteEmptyOrHR(parent);\n      } else if ([...el.children].filter(child => !child.classList.contains("footnote-print-only")).length === [...el.children].filter(child => child.tagName === \'HR\' && !child.classList.contains("footnote-print-only")).length) {\n        parent = el.parentElement;\n        if (settings.actionOriginalFN.toLowerCase() === "delete") {\n          el.remove();\n        } else {\n          [...el.querySelectorAll("hr")].forEach(hr => hr.classList.add("footnote-print-only"));\n          el.classList.add("footnote-print-only");\n        }\n        return deleteEmptyOrHR(parent);\n      }\n    };\n    const removeBackLinks = (footnoteHTML, backlinkID) => {\n      if (backlinkID.includes(\' \')) {\n        backlinkID = backlinkID.trim().replace(/\\s+/g, "|").replace(/(.*)/g, "($1)");\n      }\n      const regex = new RegExp(`(\\\\s|&nbsp;)*<\\\\s*a[^#<]*#${backlinkID}[^>]*>(.*?)<\\\\s*/\\\\s*a>`, "g");\n      return footnoteHTML.replace(regex, "").replace("[]", "");\n    };\n\n    /************ EVENT HANDLERS *************/\n\n    const buttonHover = event => {\n      if (settings.activateOnHover) {\n        const buttonHovered = event.target.closest(".tinyfoot-footnote__button");\n        const dataIdentifier = `[data-footnote-identifier=\'${buttonHovered.getAttribute("data-footnote-identifier")}\']`;\n        if (buttonHovered.classList.contains("is-active")) {\n          return;\n        }\n        buttonHovered.classList.add("is-hover-instantiated");\n        if (!settings.allowMultipleFN) {\n          const otherPopoverSelector = `.tinyfoot-footnote:not(${dataIdentifier})`;\n          removePopovers(otherPopoverSelector);\n        }\n        createPopover(`.tinyfoot-footnote__button${dataIdentifier}`).classList.add("is-hover-instantiated");\n      }\n    };\n    const touchClick = event => {\n      const target = event.target;\n      const nearButton = target.closest(".tinyfoot-footnote__button");\n      const nearFootnote = target.closest(".tinyfoot-footnote");\n      if (nearButton) {\n        event.preventDefault();\n        clickButton(nearButton);\n      } else if (!nearFootnote) {\n        if (document.querySelector(".tinyfoot-footnote")) {\n          removePopovers();\n        }\n      }\n    };\n    const clickButton = function (button) {\n      let dataIdentifier;\n      button.blur();\n      dataIdentifier = `data-footnote-identifier=\'${button.getAttribute("data-footnote-identifier")}\'`;\n      if (button.classList.contains("changing")) {\n        return;\n      } else if (!button.classList.contains("is-active")) {\n        button.classList.add("changing");\n        setTimeout(function () {\n          button.classList.remove("changing");\n        }, settings.popoverCreateDelay);\n        createPopover(`.tinyfoot-footnote__button[${dataIdentifier}]`);\n        button.classList.add("is-click-instantiated");\n        if (!settings.allowMultipleFN) {\n          removePopovers(`.tinyfoot-footnote:not([${dataIdentifier}])`);\n        }\n      } else {\n        if (!settings.allowMultipleFN) {\n          removePopovers();\n        } else {\n          removePopovers(`.tinyfoot-footnote[${dataIdentifier}]`);\n        }\n      }\n    };\n    const escapeKeypress = function (event) {\n      if (event.keyCode === 27) {\n        return removePopovers();\n      }\n    };\n    const unhoverFeet = e => {\n      if (settings.deleteOnUnhover && settings.activateOnHover) {\n        return setTimeout(() => {\n          const target = e.target.closest(".tinyfoot-footnote, .tinyfoot-footnote__button");\n          if (!document.querySelector(".tinyfoot-footnote__button:hover, .tinyfoot-footnote:hover")) {\n            return removePopovers();\n          }\n        }, settings.hoverDelay);\n      }\n    };\n    const bindScrollHandler = function () {\n      if (!settings.preventPageScroll) {\n        return this;\n      }\n      this.addEventListener("DOMMouseScroll", function (event) {\n        scrollHandler(event, this);\n      });\n      this.addEventListener("mousewheel", function (event) {\n        scrollHandler(event, this);\n      });\n      return this;\n    };\n    const scrollHandler = function (event, el) {\n      let popover = el.closest(".tinyfoot-footnote");\n      let scrollTop = el.scrollTop;\n      let scrollHeight = el.scrollHeight;\n      let height = parseInt(getComputedStyle(el).height);\n      if (scrollTop > 0 && scrollTop < 10) {\n        popover.classList.add("is-scrollable");\n      }\n      if (!popover.classList.contains("is-scrollable")) {\n        return;\n      }\n      let delta = event.type === "DOMMouseScroll" ? event.detail * -40 : event.wheelDelta;\n      let up = delta > 0;\n      const prevent = function () {\n        event.stopPropagation();\n        event.preventDefault();\n        return false;\n      };\n      if (!up && -delta > scrollHeight - height - scrollTop) {\n        el.scrollTop = scrollHeight;\n        popover.classList.add("is-fully-scrolled");\n        return prevent();\n      } else if (up && delta > scrollTop) {\n        el.scrollTop = 0;\n        popover.classList.remove("is-fully-scrolled");\n        return prevent();\n      } else {\n        popover.classList.remove("is-fully-scrolled");\n      }\n    };\n    const repositionFeet = function (e) {\n      if (settings.positionContent) {\n        let type = e ? e.type : "resize";\n        document.querySelectorAll(".tinyfoot-footnote").forEach(footnote => {\n          // Retrieve dimensions and positioning details\n          let identifier = footnote.getAttribute("data-footnote-identifier");\n          let contentWrapper = footnote.querySelector(".tinyfoot-footnote__content");\n          let button = document.querySelector(`.tinyfoot-footnote__button[data-footnote-identifier=\'${identifier}\']`);\n          let roomLeft = roomCalc(button);\n          let marginSize = parseFloat(getComputedStyle(footnote).marginTop);\n          let maxHeightInCSS = parseFloat(footnote.getAttribute("data-tinyfoot-max-height"));\n          let totalHeight = 2 * marginSize + footnote.offsetHeight;\n          let maxHeightOnScreen = 10000;\n\n          // Determine position (top or bottom)\n          let positionOnTop = roomLeft.bottomRoom < totalHeight && roomLeft.topRoom > roomLeft.bottomRoom;\n          let lastState = popoverStates[identifier];\n          // Update classes and max heights\n          if (positionOnTop) {\n            if (lastState !== "top") {\n              popoverStates[identifier] = "top";\n              footnote.classList.add("is-positioned-top");\n              footnote.classList.remove("is-positioned-bottom");\n              footnote.style.transformOrigin = `${roomLeft.leftRelative * 100}% 100%`;\n            }\n            maxHeightOnScreen = roomLeft.topRoom - marginSize - 15;\n          } else {\n            if (lastState !== "bottom" || lastState === "init") {\n              popoverStates[identifier] = "bottom";\n              footnote.classList.remove("is-positioned-top");\n              footnote.classList.add("is-positioned-bottom");\n              footnote.style.transformOrigin = `${roomLeft.leftRelative * 100}% 0%`;\n            }\n            maxHeightOnScreen = roomLeft.bottomRoom - marginSize - 15;\n          }\n          contentWrapper.style.maxHeight = `${Math.min(maxHeightOnScreen, maxHeightInCSS)}px`;\n          thisElement = footnote;\n          // Resize handling\n          if (type === "resize") {\n            // Get maxWidthInCSS from the data attribute "tinyfoot-max-width"\n            const maxWidthInCSS = parseFloat(thisElement.getAttribute("tinyfoot-max-width"));\n\n            // Select the main wrapper for the footnote\n            const mainWrap = thisElement.querySelector(".tinyfoot-footnote__wrapper");\n\n            // Set maxWidth initially based on the CSS value\n            let maxWidth = maxWidthInCSS;\n\n            // If the maxWidth is defined as a relative value (<= 1)\n            if (maxWidthInCSS <= 1) {\n              const relativeToWidth = function () {\n                let userSpecifiedRelativeElWidth = 10000;\n\n                // Check if settings specify an element to calculate the relative width against\n                if (settings.maxWidthRelativeTo) {\n                  const relativeElement = document.querySelector(settings.maxWidthRelativeTo);\n                  if (relativeElement) {\n                    userSpecifiedRelativeElWidth = relativeElement.offsetWidth;\n                  }\n                }\n\n                // Use the minimum width between the window\'s inner width and the relative element width\n                return Math.min(window.innerWidth, userSpecifiedRelativeElWidth);\n              }();\n\n              // Calculate maxWidth based on relative width\n              maxWidth = relativeToWidth * maxWidthInCSS;\n            }\n\n            // Ensure maxWidth doesn\'t exceed the content width plus 1\n            const contentElement = thisElement.querySelector(".tinyfoot-footnote__content");\n            maxWidth = Math.min(maxWidth, contentElement.offsetWidth + 1);\n\n            // Set the max-width of the main wrapper\n            mainWrap.style.maxWidth = `${maxWidth}px`;\n\n            // Calculate the left position and set it\n            const buttonMarginLeft = parseFloat(window.getComputedStyle(button).marginLeft);\n            const buttonOuterWidth = button.offsetWidth;\n            thisElement.style.left = `${-roomLeft.leftRelative * maxWidth + buttonMarginLeft + buttonOuterWidth / 2}px`;\n\n            // Call positionTooltip with the current element and leftRelative value\n            positionTooltip(thisElement, roomLeft.leftRelative);\n          }\n\n          // Scroll handling\n          if (footnote.offsetHeight < contentWrapper.scrollHeight) {\n            footnote.classList.add("is-scrollable");\n          }\n        });\n      }\n    };\n\n    /************ AUXILLIARY FUNCTIONS *************/\n\n    const calculatePixelDimension = function (dim, el) {\n      if (dim === "none") {\n        dim = 10000; // Very large value for "none"\n      } else if (dim.includes("rem")) {\n        dim = parseFloat(dim) * baseFontSize();\n      } else if (dim.includes("em")) {\n        dim = parseFloat(dim) * parseFloat(getComputedStyle(el).fontSize);\n      } else if (dim.includes("px")) {\n        dim = parseFloat(dim);\n        if (dim <= 60) {\n          dim = dim / parseFloat(getComputedStyle(el.parentNode).width);\n        }\n      } else if (dim.includes("%")) {\n        dim = parseFloat(dim) / 100;\n      }\n      return dim;\n    };\n    const baseFontSize = () => {\n      const el = document.createElement("div");\n      el.style.cssText = "display:inline-block;padding:0;line-height:1;position:absolute;visibility:hidden;font-size:1em;";\n      el.appendChild(document.createElement("M"));\n      document.body.appendChild(el);\n      const size = el.offsetHeight;\n      document.body.removeChild(el);\n      return size;\n    };\n    const addBreakpoint = (size, trueCallback, falseCallback, deleteDelay = settings.popoverDeleteDelay, removeOpen = true) => {\n      let mql, minMax, s, query;\n      if (typeof size === "string") {\n        s = size.toLowerCase() === "iphone" ? "<320px" : size.toLowerCase() === "ipad" ? "<768px" : size;\n        minMax = s.charAt(0) === ">" ? "min" : s.charAt(0) === "<" ? "max" : null;\n        query = minMax ? `(${minMax}-width: ${s.substring(1)})` : s;\n        mql = window.matchMedia(query);\n      } else {\n        mql = size;\n      }\n      if (mql.media && mql.media === "invalid") {\n        return {\n          added: false,\n          mq: mql,\n          listener: null\n        };\n      }\n      const trueDefaultPositionSetting = minMax === "min";\n      const falseDefaultPositionSetting = minMax === "max";\n      trueCallback = trueCallback || makeDefaultCallbacks(removeOpen, deleteDelay, trueDefaultPositionSetting, $popover => {\n        $popover.classList.add("is-bottom-fixed");\n      });\n      falseCallback = falseCallback || makeDefaultCallbacks(removeOpen, deleteDelay, falseDefaultPositionSetting, () => {});\n      const mqListener = mq => {\n        if (mq.matches) {\n          trueCallback(removeOpen, tinyfoot);\n        } else {\n          falseCallback(removeOpen, tinyfoot);\n        }\n      };\n      mql.addEventListener(\'change\', mqListener);\n      mqListener(mql);\n      settings.breakpoints[size] = {\n        added: true,\n        mq: mql,\n        listener: mqListener\n      };\n      return settings.breakpoints[size];\n    };\n    const makeDefaultCallbacks = (removeOpen, deleteDelay, position, callback) => {\n      return (removeOpen, tinyfoot) => {\n        let closedPopovers;\n        if (removeOpen) {\n          closedPopovers = tinyfoot.close();\n          tinyfoot.updateSetting("activateCallback", callback);\n        }\n        setTimeout(() => {\n          tinyfoot.updateSetting("positionContent", position);\n          if (removeOpen) {\n            tinyfoot.activate(closedPopovers);\n          }\n        }, deleteDelay);\n      };\n    };\n    const removeBreakpoint = (target, callback) => {\n      let mqFound = false;\n      let b;\n      if (typeof target === "string") {\n        mqFound = settings.breakpoints[target] !== undefined;\n      } else {\n        for (b in settings.breakpoints) {\n          if (settings.breakpoints.hasOwnProperty(b) && settings.breakpoints[b].mq === target) {\n            mqFound = true;\n            break; // Stop the loop when the target is found\n          }\n        }\n      }\n      if (mqFound) {\n        const breakpoint = settings.breakpoints[b || target];\n        const listener = callback || breakpoint.listener;\n        listener({\n          matches: false\n        });\n        breakpoint.mq.removeEventListener(\'change\', breakpoint.listener);\n        delete settings.breakpoints[b || target];\n      }\n      return mqFound;\n    };\n    const getSetting = setting => {\n      return settings[setting];\n    };\n    const updateSetting = (newSettings, value) => {\n      let oldValue;\n      if (typeof newSettings === "string") {\n        oldValue = settings[newSettings];\n        settings[newSettings] = value;\n      } else {\n        oldValue = {};\n        for (const prop in newSettings) {\n          if (newSettings.hasOwnProperty(prop)) {\n            oldValue[prop] = settings[prop];\n            settings[prop] = newSettings[prop];\n          }\n        }\n      }\n      return oldValue;\n    };\n    const positionTooltip = function (popover, leftRelative = 0.5) {\n      const tooltip = popover.querySelector(".tinyfoot-footnote__tooltip");\n      if (tooltip) {\n        tooltip.style.left = `${leftRelative * 100}%`;\n      }\n    };\n    const roomCalc = function (el) {\n      let elStyles = getComputedStyle(el);\n      let elLeftMargin = parseFloat(elStyles.marginLeft);\n      let elWidth = el.offsetWidth - elLeftMargin;\n      let elHeight = el.offsetHeight;\n      let rect = el.getBoundingClientRect();\n      let w = viewportDetails();\n      let topRoom = rect.top + elHeight / 2;\n      let leftRoom = rect.left + elWidth / 2;\n      return {\n        topRoom: topRoom,\n        bottomRoom: w.height - topRoom,\n        leftRoom: leftRoom,\n        rightRoom: w.width - leftRoom,\n        leftRelative: leftRoom / w.width,\n        topRelative: topRoom / w.height\n      };\n    };\n    const viewportDetails = function () {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        scrollX: window.pageXOffset || document.documentElement.scrollLeft,\n        scrollY: window.pageYOffset || document.documentElement.scrollTop\n      };\n    };\n\n    /************ CREATING AND REMOVING POPOVERS *************/\n\n    const createPopover = function (selector) {\n      let buttons,\n        popoversCreated = [];\n\n      // Determine button elements based on selector and settings\n      if (typeof selector !== "string" && settings.allowMultipleFN) {\n        buttons = selector;\n      } else if (typeof selector !== "string") {\n        buttons = [selector[0]]; // Convert first element to array\n      } else if (settings.allowMultipleFN) {\n        buttons = document.querySelectorAll(selector);\n      } else {\n        buttons = [document.querySelector(selector).closest(".tinyfoot-footnote__button")];\n      }\n\n      // Process each button\n      buttons.forEach(button => {\n        let content, contentContainer;\n        try {\n          content = settings.contentMarkup.replace(/\\{\\{FOOTNOTENUM\\}\\}/g, button.getAttribute("data-footnote-number")).replace(/\\{\\{FOOTNOTEID\\}\\}/g, button.getAttribute("data-footnote-identifier")).replace(/\\{\\{FOOTNOTECONTENT\\}\\}/g, button.getAttribute("data-tinyfoot-footnote")).replace(/\\&gtsym\\;/g, "&gt;").replace(/\\&ltsym\\;/g, "&lt;");\n          content = replaceWithReferenceAttributes(content, "BUTTON", button);\n        } finally {\n          // Create and configure the content element\n          const range = document.createRange();\n          const contentElement = range.createContextualFragment(content).firstElementChild;\n          //content has "<aside>...</aside>"; contextual fragment creates a fragment out of the content string and firstelement generates ref to the actual element\n          //this method avoids creating a <div> and then adding content to its innerHTML\n          try {\n            settings.activateCallback(contentElement, button);\n          } catch (error) {}\n\n          // Insert the contentElement after the button\n          button.insertAdjacentElement(\'afterend\', contentElement);\n          popoverStates[button.getAttribute("data-footnote-identifier")] = "init";\n          const maxWidth = calculatePixelDimension(getComputedStyle(contentElement).maxWidth, contentElement);\n          contentElement.setAttribute("tinyfoot-max-width", maxWidth);\n          contentElement.style.maxWidth = "10000px"; // Set large max-width for animation\n          contentElement.style.transitionDuration = settings.animationDuration + "ms";\n\n          // Configure the content container\n          contentContainer = contentElement.querySelector(".tinyfoot-footnote__content");\n          const maxHeight = calculatePixelDimension(getComputedStyle(contentContainer).maxHeight, contentContainer);\n          contentElement.setAttribute("data-tinyfoot-max-height", maxHeight);\n          repositionFeet();\n          button.classList.add("is-active");\n\n          // Bind scroll handler to content container\n          bindScrollHandler.call(contentContainer);\n\n          // Track created popovers\n          popoversCreated.push(contentElement);\n        }\n      });\n      setTimeout(() => {\n        popoversCreated.forEach(popover => {\n          popover.classList.add("is-active");\n        });\n      }, settings.popoverCreateDelay);\n      return popoversCreated;\n    };\n    const removePopovers = (footnotes = ".tinyfoot-footnote", timeout = settings.popoverDeleteDelay) => {\n      let buttonsClosed = [];\n      const footnoteElements = document.querySelectorAll(footnotes);\n      footnoteElements.forEach(footnote => {\n        const footnoteID = footnote.getAttribute("data-footnote-identifier");\n        const linkedButton = document.querySelector(`.tinyfoot-footnote__button[data-footnote-identifier=\'${footnoteID}\']`);\n        if (!linkedButton.classList.contains("changing")) {\n          buttonsClosed.push(linkedButton);\n          linkedButton.classList.remove("is-active", "is-hover-instantiated", "is-click-instantiated");\n          linkedButton.classList.add("changing");\n          footnote.classList.remove("is-active");\n          footnote.classList.add("disapearing");\n          setTimeout(() => {\n            footnote.remove();\n            delete popoverStates[footnoteID];\n            linkedButton.classList.remove("changing");\n          }, timeout);\n        }\n      });\n      return buttonsClosed;\n    };\n\n    /************ MAPPING EVENT LISTENERS TO EVENT HANDLERS *************/\n\n    const addEventListeners = () => {\n      document.addEventListener("mouseenter", event => {\n        if (event.target.matches(".tinyfoot-footnote__button")) {\n          buttonHover(event);\n        }\n      });\n      document.addEventListener("touchend", touchClick);\n      document.addEventListener("click", touchClick);\n      document.addEventListener("mouseout", event => {\n        if (event.target.classList.contains("is-hover-instantiated")) {\n          unhoverFeet(event);\n        }\n      });\n      document.addEventListener("keyup", escapeKeypress);\n      window.addEventListener("scroll", repositionFeet);\n      window.addEventListener("resize", repositionFeet);\n      window.addEventListener("gestureend", () => {\n        repositionFeet();\n      });\n    };\n    document.addEventListener(\'DOMContentLoaded\', () => {\n      footnoteInit();\n      addEventListeners();\n    });\n    return {\n      removePopovers: removePopovers,\n      close: removePopovers,\n      createPopover: createPopover,\n      activate: createPopover,\n      repositionFeet: repositionFeet,\n      reposition: repositionFeet,\n      addBreakpoint: addBreakpoint,\n      removeBreakpoint: removeBreakpoint,\n      getSetting: getSetting,\n      updateSetting: updateSetting\n    };\n  };\n  window.tinyfoot = tinyfoot;\n})();\n\n//# sourceURL=webpack://tinyfoot/./src/js/tinyfoot.js?')}},__webpack_exports__={};__webpack_modules__["./src/js/tinyfoot.js"]()})();